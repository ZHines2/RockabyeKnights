<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Rockabye Knights — Vertical Prototype</title>
<style>
  :root{
    --bg:#0b0f14; --ink:#e9f2ff; --muted:#9aa7b3; --panel:#121824; --accent:#76a7ff;
    --good:#34d399; --warn:#fbbf24; --bad:#f87171; --line:#233047;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);
    font:14px/1.4 ui-monospace, Menlo, Consolas, monospace;}
  .wrap{position:relative; margin:0 auto; height:100vh; max-width:520px;
    background:linear-gradient(#0b0f14,#0c121c); display:flex; align-items:center; justify-content:center;}
  canvas{display:block; touch-action:none; background:#0a101a; object-fit:contain;}
  /* HUD */
  .hud{position:absolute; inset:0; pointer-events:none; display:flex; flex-direction:column;}
  .topbar{display:flex; gap:8px; padding:8px; align-items:center; justify-content:space-between;}
  .pill{pointer-events:auto; background:rgba(255,255,255,.06); border:1px solid var(--line);
    border-radius:999px; padding:6px 10px; color:var(--ink); user-select:none}
  .stat{display:flex; align-items:center; gap:6px;}
  .bar{width:120px;height:8px;border:1px solid var(--line); border-radius:6px; overflow:hidden}
  .bar > i{display:block;height:100%;}
  .hp   > i{background:linear-gradient(90deg,#34d399,#059669);}
  .combo> i{background:linear-gradient(90deg,#76a7ff,#22d3ee);}
  .pause{cursor:pointer; transition: background-color 0.15s, color 0.15s;}
  .pause:hover{background:rgba(255,255,255,.12); color:#76a7ff;}
  /* Touch controls */
  .controls{pointer-events:none; position:absolute; inset:0;}
  .joy, .buttons{position:absolute; bottom:18px; display:flex; align-items:center;}
  .joy{left:18px;}
  .buttons{right:18px; gap:16px;}
  .stick{pointer-events:auto; width:120px; height:120px; border-radius:50%;
    background:rgba(255,255,255,.05); border:1px solid var(--line); position:relative;}
  .knob{position:absolute; width:50px;height:50px;border-radius:50%;
    left:50%; top:50%; transform:translate(-50%,-50%);
    background:rgba(255,255,255,.15); border:1px solid var(--line);}
  .btn{pointer-events:auto; width:72px;height:72px;border-radius:50%;
    background:rgba(255,255,255,.08); border:1px solid var(--line);
    display:grid; place-items:center; user-select:none;
    transition: background-color 0.15s, transform 0.1s, border-color 0.15s;}
  .btn:hover{background:rgba(255,255,255,.12); border-color:#76a7ff;}
  .btn:active{transform:scale(0.95); background:rgba(255,255,255,.15);}
  .btn b{font-size:18px; opacity:.9}
  .hint{position:absolute; bottom:150px; right:18px; color:var(--muted); font-size:12px;}
  /* Overlay messages */
  .center{position:absolute; inset:0; display:grid; place-items:center; pointer-events:none;}
  .center[hidden]{display:none;}
  .msg{background:rgba(0,0,0,.4); border:1px solid var(--line); padding:10px 14px; border-radius:8px;}
</style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="450" height="800"></canvas>

    <div class="hud">
      <div class="topbar">
        <div class="stat">
          <span class="pill">KOs <b id="ko">0</b></span>
          <span class="pill">Wave <b id="wave">1</b></span>
          <span class="pill" id="debugIndicator" style="background: rgba(251, 191, 36, 0.2); border-color: #fbbf24;">DEBUG</span>
          <span class="pill">FPS <b id="fps">60</b></span>
        </div>
        <div style="display:flex; gap:10px; align-items:center">
          <span class="pill stat">
            HP
            <span class="bar hp"><i id="hpbar" style="width:100%"></i></span>
          </span>
          <span class="pill stat">
            Combo
            <span class="bar combo"><i id="combobar" style="width:0%"></i></span>
          </span>
          <span id="pause" class="pill pause" title="P">⏸ Pause</span>
        </div>
      </div>
      <div class="center" id="overlay" hidden>
        <div class="msg" id="overlayText">Paused</div>
      </div>
    </div>

    <!-- Touch Controls -->
    <div class="controls">
      <div class="joy">
        <div class="stick" id="stick"><div class="knob" id="knob"></div></div>
      </div>
      <div class="buttons">
        <div class="btn" id="btnA" title="Attack (J)"><b>A</b></div>
        <div class="btn" id="btnB" title="Dash (K)"><b>B</b></div>
      </div>
      <div class="hint">J = Attack • K = Dash • P = Pause • G = Debug</div>
    </div>
  </div>

<script>
(() => {
  // ===== Canvas & Timing =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); // cap for perf
  function resize() {
    // Keep portrait aspect (450x800 logical), scale with DPR for crispness
    const container = canvas.parentElement;
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;
    
    // Calculate scale to fit while maintaining aspect ratio
    const aspectRatio = GAME_W / GAME_H; // 450/800 = 0.5625
    const containerAspect = containerWidth / containerHeight;
    
    let displayWidth, displayHeight;
    if (containerAspect > aspectRatio) {
      // Container is wider than game aspect ratio - fit to height
      displayHeight = containerHeight;
      displayWidth = displayHeight * aspectRatio;
    } else {
      // Container is taller than game aspect ratio - fit to width
      displayWidth = containerWidth;
      displayHeight = displayWidth / aspectRatio;
    }
    
    canvas.style.width = `${displayWidth}px`;
    canvas.style.height = `${displayHeight}px`;
    canvas.width  = Math.round(GAME_W * DPR);
    canvas.height = Math.round(GAME_H * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0); // draw in logical units
  }
  const ro = new ResizeObserver(resize);
  ro.observe(canvas);

  // ===== UI Elements =====
  const elKO = document.getElementById('ko');
  const elWave = document.getElementById('wave');
  const elFPS = document.getElementById('fps');
  const elHP = document.getElementById('hpbar');
  const elCombo = document.getElementById('combobar');
  const elDebugIndicator = document.getElementById('debugIndicator');
  const pauseBtn = document.getElementById('pause');
  const overlay = document.getElementById('overlay');
  const overlayText = document.getElementById('overlayText');

  // ===== Input (Keyboard) =====
  const keys = new Set();
  window.addEventListener('keydown', e=>{
    if (state.showWelcome) {
      // Any key dismisses welcome screen
      state.showWelcome = false;
      return;
    }
    
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'].includes(e.key)) e.preventDefault();
    keys.add(e.key.toLowerCase());
    if (e.key.toLowerCase()==='p') togglePause();
    if (e.key.toLowerCase()==='j') pressAttack();
    if (e.key.toLowerCase()==='k') pressDash();
    if (e.key.toLowerCase()==='g') toggleDebugMode();
  });
  window.addEventListener('keyup', e=> keys.delete(e.key.toLowerCase()));

  // ===== Input (Touch Joystick + Buttons) =====
  const stick = document.getElementById('stick');
  const knob  = document.getElementById('knob');
  const btnA  = document.getElementById('btnA');
  const btnB  = document.getElementById('btnB');

  let joyActive = false, joyDX = 0, joyDY = 0;
  function joyFromEvent(ev){
    const rect = stick.getBoundingClientRect();
    const t = (ev.touches?.[0]) || ev;
    const x = t.clientX - rect.left - rect.width/2;
    const y = t.clientY - rect.top  - rect.height/2;
    const max = rect.width*0.38;
    const len = Math.hypot(x,y);
    let dx = x, dy = y;
    if (len > max){ const s = max/len; dx*=s; dy*=s; }
    knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
    const nx = (len>6? dx/max : 0), ny = (len>6? dy/max : 0);
    joyDX = nx; joyDY = ny;
  }
  function joyEnd(){
    joyActive=false; joyDX=0; joyDY=0; knob.style.transform='translate(-50%,-50%)';
  }
  stick.addEventListener('mousedown', e=>{ joyActive=true; joyFromEvent(e); });
  stick.addEventListener('mousemove', e=>{ if(joyActive) joyFromEvent(e); });
  window.addEventListener('mouseup', joyEnd);
  stick.addEventListener('touchstart', e=>{ joyActive=true; joyFromEvent(e); }, {passive:false});
  stick.addEventListener('touchmove',  e=>{ e.preventDefault(); if(joyActive) joyFromEvent(e); }, {passive:false});
  stick.addEventListener('touchend',   joyEnd);

  btnA.addEventListener('mousedown', ()=>{
    if (state.showWelcome) { state.showWelcome = false; return; }
    pressAttack();
  });
  btnA.addEventListener('touchstart', e=>{ 
    e.preventDefault(); 
    if (state.showWelcome) { state.showWelcome = false; return; }
    pressAttack(); 
  }, {passive:false});
  btnB.addEventListener('mousedown', ()=>{
    if (state.showWelcome) { state.showWelcome = false; return; }
    pressDash();
  });
  btnB.addEventListener('touchstart', e=>{ 
    e.preventDefault(); 
    if (state.showWelcome) { state.showWelcome = false; return; }
    pressDash(); 
  }, {passive:false});

  // Canvas click to dismiss welcome or restart
  canvas.addEventListener('click', ()=>{
    if (state.showWelcome) {
      state.showWelcome = false;
    } else if (!state.running) {
      resetGame(); state.running=true; overlay.hidden=true; pauseBtn.textContent='⏸ Pause';
    }
  });

  pauseBtn.addEventListener('click', togglePause);

  // ===== Helpers =====
  const rand = (a,b)=> a + Math.random()*(b-a);
  const clamp = (v,min,max)=> Math.max(min, Math.min(max,v));
  const lerp = (a,b,t)=> a+(b-a)*t;
  const now = ()=> performance.now();

  // ===== World / Entities =====
  const GAME_W = 450, GAME_H = 800;
  const GROUND = GAME_H - 40;

  const state = {
    running: true,
    showWelcome: true, // Show welcome screen initially
    debugMode: true, // DEBUG: Single enemy spawning mode
    time: 0,
    ko: 0,
    wave: 1,
    spawnTimer: 2.0, // Start with more breathing room
    spawnRate: 1.8, // Slower initial spawn rate for better new player experience
    enemies: [],
    effects: [],
    // Screen shake for juicy feedback
    shakeX: 0, shakeY: 0, shakeIntensity: 0, shakeDuration: 0,
  };

  const player = {
    x: GAME_W/2, y: GROUND-60, r: 12,
    vx: 0, vy: 0, speed: 170,
    hp: 100, hpMax: 100, ifr: 0,
    facing: 1, // 1 right, -1 left
    attackCD: 0,
    dashCD: 0, dashing: 0, dashSpeed: 420,
    combo: 0, comboTimer: 0, comboWindow: 2.0,
  };

  // DEBUG: Expose variables globally for debugging
  if (typeof window !== 'undefined') {
    window.gameState = state;
    window.gamePlayer = player;
  }

  function resetGame() {
    state.ko=0; state.wave=1; state.spawnRate=1.8; state.enemies.length=0; state.effects.length=0;
    state.shakeX=0; state.shakeY=0; state.shakeIntensity=0; state.shakeDuration=0;
    state.showWelcome = false; // Hide welcome when restarting
    state.spawnTimer = 2.0; // Give player time to orient
    // DEBUG MODE: Keep debug mode setting across resets
    player.x=GAME_W/2; player.y=GROUND-60; player.vx=0; player.vy=0;
    player.hp=player.hpMax; player.ifr=0; player.attackCD=0; player.dashCD=0; player.dashing=0;
    player.combo=0; player.comboTimer=0;
    updateHUD();
  }

  // ===== Actions =====
  function pressAttack(){
    if (!state.running) return;
    if (player.attackCD>0) return;
    player.attackCD = 0.25; // seconds
    // Attack arc: short-range melee in facing direction
    const reach = state.debugMode ? 50 : 34; // Increased reach in debug mode
    const ax = player.x + player.facing* (player.r + reach);
    const ay = player.y - 4;
    // spawn a slash effect
    spawnSlash(ax - player.facing*8, ay-8, player.facing);
    // damage enemies in small box
    const dmg = 20 + Math.floor(player.combo*0.5);
    const hitWidth = state.debugMode ? 100 : 40;  // Much wider hit area in debug mode
    const hitHeight = state.debugMode ? 80 : 26;  // Much taller hit area in debug mode
    const hit = hitEnemies(ax, ay, hitWidth, hitHeight, dmg, 240*player.facing, -60);
    if (hit>0) {
      addCombo(hit);
    } else {
      // light whiff effect
      state.effects.push({t:0, life:0.15, kind:'whiff', x:ax, y:ay});
    }
  }

  function pressDash(){
    if (!state.running) return;
    if (player.dashCD>0) return;
    player.dashing = 0.18; // seconds
    player.dashCD = 0.7;
    // tiny dash puff
    state.effects.push({t:0, life:0.25, kind:'dash', x:player.x - player.facing*10, y:player.y});
  }

  function addCombo(n){
    player.combo += n;
    player.comboTimer = player.comboWindow;
    // Show combo text for satisfying feedback
    if (player.combo > 1) {
      state.effects.push({
        t:0, life:0.8, kind:'combo', 
        x:player.x, y:player.y - 30,
        combo: player.combo
      });
    }
  }

  function toggleDebugMode(){
    state.debugMode = !state.debugMode;
    updateHUD();
    console.log('Debug mode:', state.debugMode ? 'ON (Single enemy)' : 'OFF (Normal spawning)');
  }

  function togglePause(){
    if (state.showWelcome) return; // Can't pause during welcome
    state.running = !state.running;
    overlay.hidden = state.running;
    if (!state.running) {
      overlayText.innerHTML = `
        <div style="text-align:center;">
          <div style="color:#76a7ff;font-size:18px;margin-bottom:8px;">⏸ Game Paused</div>
          <div style="color:#9aa7b3;font-size:14px;">Press P or click Pause to resume</div>
        </div>
      `;
    }
    pauseBtn.textContent = state.running ? '⏸ Pause' : '▶ Resume';
  }

  // ===== Enemies =====
  function spawnEnemy(){
    // Spawn from top edges or sides
    const edge = Math.floor(Math.random()*3);
    let x, y;
    if (edge===0){ x = Math.random()<0.5? -20 : GAME_W+20; y = rand(GROUND-180,GROUND-20); }
    else { x = rand(20, GAME_W-20); y = -20; }
    const hp = rand(28, 42) + state.wave*3;
    state.enemies.push({
      x, y, vx:0, vy:0, r:10,
      hp, hpMax:hp, speed: rand(80, 110)+ state.wave*2,
      knock:0, ifr:0, kind: (Math.random()<0.85?'grunt':'brute'),
      tint: Math.random()<0.1? '#9b59b6' : '#a3e635',
    });
  }

  function nextWave(){
    state.wave++;
    state.spawnRate = Math.max(0.6, state.spawnRate - 0.12);
    // Show wave progression for satisfying feedback
    state.effects.push({
      t:0, life:2.0, kind:'wave', 
      x:GAME_W/2, y:GAME_H/2,
      wave: state.wave
    });
  }

  function hitEnemies(cx, cy, w, h, dmg, kx, ky){
    let hits = 0;
    for (const e of state.enemies){
      if (e.hp<=0) continue;
      if (e.ifr>0) continue;
      if (Math.abs(e.x - cx) < w/2 && Math.abs(e.y - cy) < h/2){
        e.hp -= dmg;
        e.ifr = 0.12;
        e.knock = 0.12;
        e.vx += kx * (0.5 + Math.random()*0.5);
        e.vy += ky;
        hits++;
        // blood/crit puff
        state.effects.push({t:0, life:0.25, kind:'hit', x:e.x, y:e.y});
        // Add impact sparks for more satisfying feedback
        for (let i = 0; i < 3; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 80 + Math.random() * 40;
          state.effects.push({
            t:0, life:0.3, kind:'spark', 
            x:e.x, y:e.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed
          });
        }
        if (e.hp<=0){
          // KO!
          state.ko++;
          if (state.debugMode) {
            console.log('Enemy KOd! Total KOs:', state.ko, 'Enemy was at:', e.x, e.y);
          }
          // pop effect + small heal on kill to keep flow
          state.effects.push({t:0, life:0.35, kind:'ko', x:e.x, y:e.y});
          addScreenShake(3, 0.1); // Light shake for enemy defeat
          if (player.hp<player.hpMax) player.hp = Math.min(player.hpMax, player.hp+4);
        }
      }
    }
    return hits;
  }

  // ===== Effects =====
  function spawnSlash(x,y,dir){
    state.effects.push({t:0, life:0.15, kind:'slash', x, y, dir});
  }

  function addScreenShake(intensity, duration) {
    state.shakeIntensity = Math.max(state.shakeIntensity, intensity);
    state.shakeDuration = Math.max(state.shakeDuration, duration);
  }

  // ===== Update & Draw =====
  let last = now(), frame = 0, fpsTimer = 0, fpsCount = 0, fps = 60;

  function update(dt){
    state.time += dt;
    
    // Skip main game logic if showing welcome screen
    if (state.showWelcome) return;

    // Input vector
    let ix = 0, iy = 0;
    if (joyDX || joyDY){ ix=joyDX; iy=joyDY; }
    else {
      ix = (keys.has('arrowright')||keys.has('d')) - (keys.has('arrowleft')||keys.has('a'));
      iy = (keys.has('arrowdown')||keys.has('s')) - (keys.has('arrowup')||keys.has('w'));
    }
    const len = Math.hypot(ix,iy);
    if (len>1e-3){ ix/=len; iy/=len; player.facing = (ix!==0? Math.sign(ix): player.facing); }

    // Player cooldowns
    player.attackCD = Math.max(0, player.attackCD - dt);
    player.dashCD   = Math.max(0, player.dashCD   - dt);
    player.ifr      = Math.max(0, player.ifr      - dt);
    if (player.comboTimer>0){
      player.comboTimer -= dt;
      if (player.comboTimer<=0){ player.combo=0; player.comboTimer=0; }
    }

    // Player movement
    const base = player.speed * (player.dashing>0 ? 2.2 : 1.0);
    player.vx = ix * base;
    player.vy = iy * base;
    player.x += player.vx * dt;
    player.y += player.vy * dt;
    player.x = clamp(player.x, 16, GAME_W-16);
    player.y = clamp(player.y, 16, GROUND);

    if (player.dashing>0) player.dashing -= dt;

    // Enemy spawn logic
    state.spawnTimer -= dt;
    if (state.spawnTimer<=0){
      state.spawnTimer = state.spawnRate;
      
      // DEBUG MODE: Only spawn if no living enemies exist
      if (state.debugMode) {
        const livingEnemies = state.enemies.filter(e => e.hp > 0);
        if (livingEnemies.length === 0) {
          spawnEnemy();
        }
      } else {
        spawnEnemy();
      }
      
      // ramp waves lightly by KOs
      if (state.ko>0 && state.ko%25===0) nextWave();
    }

    // Enemies AI & physics
    for (const e of state.enemies){
      if (e.hp<=0) continue;
      const dx = player.x - e.x, dy = player.y - e.y;
      const dlen = Math.hypot(dx,dy) || 1;
      const nx = dx/dlen, ny = dy/dlen;

      // simple seek unless knocked
      if (e.knock>0){
        e.knock -= dt;
        e.vx *= 0.94; e.vy *= 0.94;
      } else {
        e.vx = nx * e.speed;
        e.vy = ny * e.speed * 0.9;
      }
      e.ifr = Math.max(0, e.ifr - dt);
      e.x += e.vx * dt;
      e.y += e.vy * dt;
      // bounds
      e.x = clamp(e.x, 8, GAME_W-8);
      e.y = clamp(e.y, 8, GROUND-2);

      // contact damage (unless player dashing)
      if (e.hp>0 && player.dashing<=0 && !state.debugMode){ // Skip damage in debug mode
        const dist = Math.hypot(player.x-e.x, player.y-e.y);
        if (dist < player.r + e.r + 2){
          if (player.ifr<=0){
            const dmg = state.debugMode ? 5 : (e.kind==='brute'? 18:10); // Reduced damage in debug mode
            player.hp -= dmg;
            player.ifr = 0.6;
            // knock player away
            const k = 180;
            player.x += (player.x - e.x)/Math.max(2, dist) * 12;
            player.y += (player.y - e.y)/Math.max(2, dist) * 8;
            // damage effect
            state.effects.push({t:0, life:0.25, kind:'phit', x:player.x, y:player.y});
            addScreenShake(8, 0.15); // Medium shake for player damage
            if (player.hp<=0){
              player.hp=0;
              state.running=false;
              overlay.hidden=false;
              overlayText.innerHTML = `
                <div style="text-align:center;">
                  <div style="color:#f87171;font-size:18px;margin-bottom:8px;">☠ You Fell ☠</div>
                  <div style="margin-bottom:4px;">Enemies defeated: <strong>${state.ko}</strong></div>
                  <div style="margin-bottom:16px;">Wave reached: <strong>${state.wave}</strong></div>
                  <div style="color:#9aa7b3;font-size:12px;">Click anywhere, press R, or tap a button to restart</div>
                </div>
              `;
              addScreenShake(12, 0.25); // Big shake for death
              pauseBtn.textContent = '▶ Resume';
            }
          }
        }
      }
    }

    // Cull dead enemies
    const beforeCount = state.enemies.length;
    state.enemies = state.enemies.filter(e => {
      if (e && e.hp > 0) return true;
      if (e && e.x !== undefined && e.y !== undefined) {
        state.effects.push({t:0, life:0.25, kind:'pop', x:e.x, y:e.y});
        if (state.debugMode) {
          console.log('Enemy died at:', e.x, e.y, 'Effects count:', state.effects.length);
        }
      }
      return false;
    });
    const afterCount = state.enemies.length;
    if (state.debugMode && beforeCount !== afterCount) {
      console.log('Enemies before:', beforeCount, 'after:', afterCount, 'living enemies:', state.enemies.filter(e => e.hp > 0).length);
    }

    // Effects
    for (const fx of state.effects) {
      fx.t += dt;
      // Update spark positions in update function where dt is available
      if (fx.kind === 'spark') {
        fx.x += fx.vx * dt;
        fx.y += fx.vy * dt;
        fx.vy += 200 * dt; // gravity
        fx.vx *= 0.98; // air resistance
      }
    }
    state.effects = state.effects.filter(fx => fx.t < fx.life);

    // Screen shake
    if (state.shakeDuration > 0) {
      state.shakeDuration -= dt;
      const intensity = state.shakeIntensity * (state.shakeDuration / 0.2); // fade over 0.2s
      state.shakeX = (Math.random() - 0.5) * intensity * 2;
      state.shakeY = (Math.random() - 0.5) * intensity * 2;
      if (state.shakeDuration <= 0) {
        state.shakeX = 0; state.shakeY = 0; state.shakeIntensity = 0;
      }
    }

    // HUD bars
    elHP.style.width = `${(player.hp/player.hpMax)*100}%`;
    const comboPct = clamp(player.comboTimer/player.comboWindow,0,1);
    elCombo.style.width = `${comboPct*100}%`;

    updateHUD();
  }

  function updateHUD(){
    elKO.textContent = state.ko|0;
    elWave.textContent = state.wave|0;
    // Show/hide debug indicator
    if (elDebugIndicator) {
      elDebugIndicator.style.display = state.debugMode ? 'inline-flex' : 'none';
    }
  }

  function draw(){
    // Apply screen shake transform
    ctx.save();
    ctx.translate(state.shakeX, state.shakeY);
    
    // Background layers
    ctx.clearRect(-state.shakeX, -state.shakeY, canvas.width, canvas.height);
    // subtle grid
    ctx.globalAlpha = 0.12;
    ctx.strokeStyle = '#182233';
    ctx.lineWidth = 1;
    for(let y=0; y<GAME_H; y+=40){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(GAME_W,y); ctx.stroke();
    }
    for(let x=0; x<GAME_W; x+=40){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,GAME_H); ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // Ground
    ctx.fillStyle = '#0f1726';
    ctx.fillRect(0, GROUND, GAME_W, GAME_H-GROUND);

    // Draw enemies
    for (const e of state.enemies){
      if (e.hp<=0) continue;
      // Shadow for depth
      ctx.globalAlpha = 0.15;
      ctx.fillStyle = '#000';
      ctx.beginPath(); ctx.ellipse(e.x, e.y + e.r + 2, e.r * 0.8, e.r * 0.4, 0, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
      
      // body
      ctx.fillStyle = e.tint;
      ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); ctx.fill();
      
      // Special enemy indicator for brutes
      if (e.kind === 'brute') {
        ctx.strokeStyle = '#9b59b6';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(e.x, e.y, e.r + 1, 0, Math.PI*2); ctx.stroke();
      }
      
      // tiny eye facing player
      const ex = e.x + Math.sign(player.x - e.x)*3;
      ctx.fillStyle = '#0b0f14';
      ctx.fillRect(ex-1, e.y-2, 2, 2);
      // hp pip
      ctx.fillStyle = '#22324a';
      ctx.fillRect(e.x-10, e.y-16, 20, 3);
      ctx.fillStyle = '#69db7c';
      ctx.fillRect(e.x-10, e.y-16, 20*(e.hp/e.hpMax), 3);
      if (e.ifr>0){
        ctx.globalAlpha = 0.5 + 0.5*Math.sin(state.time*40);
        ctx.strokeStyle = '#fff';
        ctx.strokeRect(e.x-e.r-2, e.y-e.r-2, (e.r*2)+4, (e.r*2)+4);
        ctx.globalAlpha = 1;
      }
    }

    // Player
    // shadow
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.ellipse(player.x, player.y+player.r, player.r*1.1, player.r*0.6, 0, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;

    // body with dash glow effect
    if (player.dashing > 0) {
      // Dash glow
      const dashAlpha = player.dashing / 0.18;
      ctx.globalAlpha = 0.3 * dashAlpha;
      ctx.fillStyle = '#a5b4fc';
      ctx.beginPath(); ctx.arc(player.x, player.y, player.r + 4, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }
    
    ctx.fillStyle = player.ifr>0 ? '#ffd166' : (player.dashing>0 ? '#a5b4fc' : '#93c5fd');
    ctx.beginPath(); ctx.arc(player.x, player.y, player.r, 0, Math.PI*2); ctx.fill();
    // visor/face
    ctx.fillStyle = '#0b0f14';
    ctx.fillRect(player.x + (player.facing*4) - 3, player.y-3, 6, 3);

    // effects
    for (const fx of state.effects){
      const t = fx.t / fx.life;
      if (fx.kind==='slash'){
        ctx.save();
        ctx.translate(fx.x, fx.y);
        ctx.scale(fx.dir, 1);
        const alpha = 0.8*(1-t);
        ctx.globalAlpha = alpha;
        
        // Main slash
        ctx.strokeStyle = '#bfe3ff';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(-6, -10);
        ctx.quadraticCurveTo(16, -3, 20, 12);
        ctx.stroke();
        
        // Inner glow
        ctx.globalAlpha = alpha * 0.5;
        ctx.strokeStyle = '#e0f2fe';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.restore();
      } else if (fx.kind==='hit'){
        ctx.globalAlpha = 0.8*(1-t);
        ctx.fillStyle = '#ef4444';
        ctx.beginPath(); ctx.arc(fx.x, fx.y, 6+6*(1-t), 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
      } else if (fx.kind==='phit'){
        ctx.globalAlpha = 0.7*(1-t);
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 2;
        ctx.strokeRect(fx.x-10*(1-t), fx.y-10*(1-t), 20*(1-t*0.6), 20*(1-t*0.6));
        ctx.globalAlpha = 1;
      } else if (fx.kind==='ko' || fx.kind==='pop'){
        ctx.globalAlpha = 0.6*(1-t);
        ctx.fillStyle = fx.kind==='ko' ? '#34d399' : '#94a3b8';
        ctx.beginPath(); ctx.arc(fx.x, fx.y, 12*t, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
      } else if (fx.kind==='dash'){
        ctx.globalAlpha = 0.5*(1-t);
        ctx.fillStyle = '#a5b4fc';
        ctx.fillRect(fx.x-6, fx.y-3, 24, 6);
        ctx.globalAlpha = 1;
      } else if (fx.kind==='whiff'){
        ctx.globalAlpha = 0.4*(1-t);
        ctx.strokeStyle = '#94a3b8';
        ctx.beginPath(); ctx.arc(fx.x, fx.y, 8+8*t, 0, Math.PI*2); ctx.stroke();
        ctx.globalAlpha = 1;
      } else if (fx.kind==='spark'){
        // Render particle sparks (position already updated in update() function)
        ctx.globalAlpha = 0.8 * (1-t);
        ctx.fillStyle = t < 0.5 ? '#fbbf24' : '#f87171';
        const size = 3 * (1-t);
        ctx.fillRect(fx.x - size/2, fx.y - size/2, size, size);
        ctx.globalAlpha = 1;
      } else if (fx.kind==='combo'){
        // Floating combo text
        fx.y -= 30 * dt; // float upward
        const scale = 1 + 0.3 * (1 - t);
        ctx.save();
        ctx.translate(fx.x, fx.y);
        ctx.scale(scale, scale);
        ctx.globalAlpha = 0.9 * (1-t);
        ctx.fillStyle = player.combo >= 5 ? '#fbbf24' : '#34d399';
        ctx.font = 'bold 16px ui-monospace, monospace';
        ctx.textAlign = 'center';
        ctx.fillText(`${fx.combo}x COMBO!`, 0, 0);
        ctx.restore();
      } else if (fx.kind==='wave'){
        // Wave announcement
        const fadeIn = Math.min(1, fx.t / 0.3);
        const fadeOut = fx.t > 1.5 ? (2.0 - fx.t) / 0.5 : 1;
        const alpha = fadeIn * fadeOut;
        
        ctx.save();
        ctx.translate(fx.x, fx.y);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = '#76a7ff';
        ctx.font = 'bold 24px ui-monospace, monospace';
        ctx.textAlign = 'center';
        ctx.fillText(`WAVE ${fx.wave}`, 0, 0);
        ctx.globalAlpha = alpha * 0.7;
        ctx.font = '14px ui-monospace, monospace';
        ctx.fillText('INCOMING!', 0, 25);
        ctx.restore();
      }
    }

    // Foreground vignette
    const grd = ctx.createLinearGradient(0,0,0,GAME_H);
    grd.addColorStop(0,'rgba(0,0,0,0.35)');
    grd.addColorStop(0.08,'rgba(0,0,0,0.0)');
    grd.addColorStop(0.92,'rgba(0,0,0,0.0)');
    grd.addColorStop(1,'rgba(0,0,0,0.35)');
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,GAME_W,GAME_H);

    // Ground line
    ctx.strokeStyle = '#1b2740';
    ctx.beginPath(); ctx.moveTo(0,GROUND+0.5); ctx.lineTo(GAME_W,GROUND+0.5); ctx.stroke();

    // Welcome screen overlay
    if (state.showWelcome) {
      ctx.fillStyle = 'rgba(0,0,0,0.8)';
      ctx.fillRect(0, 0, GAME_W, GAME_H);
      
      // Title
      ctx.fillStyle = '#76a7ff';
      ctx.font = 'bold 28px ui-monospace, monospace';
      ctx.textAlign = 'center';
      ctx.fillText('ROCKABYE KNIGHTS', GAME_W/2, GAME_H/2 - 120);
      
      // Subtitle
      ctx.fillStyle = '#9aa7b3';
      ctx.font = '14px ui-monospace, monospace';
      ctx.fillText('Defend against the horde!', GAME_W/2, GAME_H/2 - 90);
      
      // Instructions
      ctx.fillStyle = '#e9f2ff';
      ctx.font = '16px ui-monospace, monospace';
      ctx.fillText('WASD / Arrow Keys - Move', GAME_W/2, GAME_H/2 - 40);
      ctx.fillText('J / A Button - Attack', GAME_W/2, GAME_H/2 - 15);
      ctx.fillText('K / B Button - Dash', GAME_W/2, GAME_H/2 + 10);
      
      // Debug mode indicator
      if (state.debugMode) {
        ctx.fillStyle = '#fbbf24';
        ctx.font = 'bold 14px ui-monospace, monospace';
        ctx.fillText('DEBUG MODE: Single Enemy', GAME_W/2, GAME_H/2 + 35);
      }
      
      ctx.fillStyle = '#9aa7b3';
      ctx.font = '12px ui-monospace, monospace';
      ctx.fillText('P - Pause • G - Toggle Debug', GAME_W/2, GAME_H/2 + 60);
      
      // Start prompt with pulse effect
      const pulse = 0.7 + 0.3 * Math.sin(state.time * 4);
      ctx.globalAlpha = pulse;
      ctx.fillStyle = '#34d399';
      ctx.font = 'bold 18px ui-monospace, monospace';
      ctx.fillText('Press any key or tap to start!', GAME_W/2, GAME_H/2 + 100);
      ctx.globalAlpha = 1;
      ctx.textAlign = 'left';
    }
    
    // Restore transform
    ctx.restore();
  }

  function loop(){
    const t = now();
    let dt = (t - last)/1000;
    last = t;

    // clamp dt to avoid big jumps on tab switch
    dt = Math.min(dt, 0.05);

    // Always update time for animations
    state.time += dt;

    if (state.running && !state.showWelcome){
      update(dt);
    }
    draw();

    // fps calc
    fpsTimer += dt;
    fpsCount++;
    if (fpsTimer >= 0.5){
      fps = Math.round(fpsCount / fpsTimer);
      elFPS.textContent = fps;
      fpsTimer = 0; fpsCount = 0;
    }

    requestAnimationFrame(loop);
  }

  // Restart on R or overlay tap
  window.addEventListener('keydown', e=>{
    if (e.key.toLowerCase()==='r' && !state.running){ 
      resetGame(); 
      state.running=true; 
      overlay.hidden=true; 
      pauseBtn.textContent='⏸ Pause'; 
    }
  });
  overlay.addEventListener('click', ()=>{
    if (!state.running){ 
      resetGame(); 
      state.running=true; 
      overlay.hidden=true; 
      pauseBtn.textContent='⏸ Pause'; 
    }
  });

  // Start
  resize(); 
  // Don't call resetGame() initially so welcome screen shows
  last = now(); 
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
